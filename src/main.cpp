/*
 *
 * THIS PROGRAM TAKES THE FOLLOWING COMMAND LINE ARGUMENTS:
 *      vertex_shader.glsl (path to vertex shader file)[REQUIRED]
 *      fragment_shader.glsl (path to fragment shader file)[REQUIRED]
 *      texture mode (0 for color, 1 for depth, 2 for texture image)
 *      texture.{png|jpg} (path to texture image)[MUST SUPPLY IF MODE IS 2]
 *
 */
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

#include "app_state.h"
#include <GLFW/glfw3.h>
#include <opencv2/opencv.hpp>
#include <iostream>
#include <cstdlib>
#include "callbacks.h"
#include "shaders.hpp"
#include <pcl/io/pcd_io.h>
#include <pcl/io/ply_io.h>
#include <pcl/point_cloud.h>
#include <pcl/console/parse.h>
#include <pcl/common/transforms.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pdal/pdal.hpp>

using namespace std;
int textureMode;

////Takes as input vertShader, fragShader
int main(int argc, const char * argv[]) {
    // Ensure that the correct number of command line arguments have been entered
    if(argc < 4){
        cout << "Please provide the following required input arguments: <vertex_shader_path>.glsl <fragment_shader_path>.glsl texture_mode" << endl;
        return 1;
    }

    // Get the paths to the vertex and fragment shader files
    const char *vertShader = argv[1];
    const char *fragShader = argv[2];
    cout << "Vertex Shader File Path: " << vertShader << endl;
    cout << "Fragment Shader File Path: " << fragShader << endl;

    // Get the texture mode: either depth or color
    // Both depth and color frames are generated by
    // the realsense camera
    const char *textureImage = NULL;
    textureMode = atoi(argv[3]);
    cout << "Texture Mode: " << textureMode << endl;
    if(textureMode == Image){
        if(argc == 5){
            textureImage = argv[4];
            cout << "Texture Image File Path: " << textureImage << endl;
        }
        else {
            cout << "Since you have selected mode 2, you must supply an image file path for texture mapping" << endl;
            return 1;
        }
    }
    // Source: http://www.pointclouds.org/documentation/tutorials/greedy_projection.php
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
    pcl::PCLPointCloud2 cloud_blob;
    pcl::io::loadPCDFile ("bun0.pcd", cloud_blob);
    pcl::fromPCLPointCloud2 (cloud_blob, *cloud);

    // OpenGL pre-window setup
    if(!glfwInit()){
        exit(EXIT_FAILURE);
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,1);
    glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT,GL_TRUE);

    GLFWwindow* window = glfwCreateWindow(1280, 720, "OpenGL RealSense", NULL, NULL);
    int actualScreenWidth; int actualScreenHeight;
    glfwGetFramebufferSize(window, &actualScreenWidth, &actualScreenHeight);
    glfwMakeContextCurrent(window);
    glViewport(0, 0, actualScreenWidth, actualScreenHeight);
    glewExperimental = GL_TRUE;
    if(glewInit() != GLEW_OK){
        exit(EXIT_FAILURE);
    }

    //Refesh rate
    glfwSwapInterval(1);

    //Set callbacks
    glfwSetWindowSizeCallback(window, window_size_callback);
    glfwSetMouseButtonCallback(window,mouse_button_callback);
    glfwSetScrollCallback(window,scroll_callback);
    glfwSetCursorPosCallback(window,cursor_pos_callback);
    glfwSetKeyCallback(window,key_callback);

    //Initialize the RealSense Camera
    rs2::pipeline pipe;
    rs2::config cfg;

    const int width = actualScreenWidth;
    const int height = actualScreenHeight;
    cfg.enable_stream(RS2_STREAM_COLOR, 640, 480, RS2_FORMAT_BGR8, 30);
    cfg.enable_stream(RS2_STREAM_DEPTH, 640, 480, RS2_FORMAT_Z16, 30);

    rs2::pipeline_profile profile = pipe.start(cfg);

    //Initialize the OpenGL window
    init(window,vertShader,fragShader,textureMode,textureImage);

    //While the window is open
    while(!glfwWindowShouldClose(window)){
        //Get a new frame from the RealSense
        auto frames = pipe.wait_for_frames();
        if(!frames){
            cerr << "Error occured while attempting to get camera frames" << endl;
            return 1;
        }

        // Extract point cloud from the frame and display it in OpenGL
//        display(window, glfwGetTime(), cloud);
        display(window,glfwGetTime(),frames);

        // Update the display
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // Release the RealSense Camera
    pipe.stop();

    // Destroy OpenGL window
    glfwDestroyWindow(window);
    glfwTerminate();
    exit(EXIT_SUCCESS);
}